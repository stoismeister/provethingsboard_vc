{
  "entityType" : "RULE_CHAIN",
  "entity" : {
    "additionalInfo" : {
      "description" : "Parsing modbus inverter Zucchetti"
    },
    "configuration" : null,
    "debugMode" : false,
    "externalId" : null,
    "firstRuleNodeId" : {
      "entityType" : "RULE_NODE",
      "id" : "48d8da20-9820-11ed-a76d-9955dd563d2d"
    },
    "id" : {
      "entityType" : "RULE_CHAIN",
      "id" : "48c997e0-9820-11ed-a76d-9955dd563d2d"
    },
    "name" : "Inverter_Zucchetti_parse",
    "root" : false,
    "type" : "CORE"
  },
  "metaData" : {
    "connections" : [ {
      "fromIndex" : 0,
      "toIndex" : 1,
      "type" : "Failure"
    }, {
      "fromIndex" : 0,
      "toIndex" : 1,
      "type" : "Success"
    } ],
    "firstNodeIndex" : 0,
    "nodes" : [ {
      "additionalInfo" : {
        "description" : "checkGTWmsg_id ricerca MODB:, MSG1/2:, row (ossia ASCII-MODBUS)",
        "layoutX" : 369,
        "layoutY" : 146
      },
      "configuration" : {
        "jsScript" : "//var msg={};\n//msg.MSG=\"MSG1:010314000001F6034F004B002000000000FFD2000008E4FED1;\";\n//msg.MSG=\"MSG2:0103160000010D009701E2000000000000055A000001100000F4D9;\";\n\n\n//msg.MSG= \"telemetry=2022-07-05 12:00:26,,,1,0,,12.9,,0,0.0,206,0,-75;\"\n\nvar row;//stringa in ingresso ed un json in uscita. row in ingresso e msg in usctita\nvar monofase = 1;\n//var monofase=metadata.shared_n_phase;\n\nvar output_msg=msg;//output\n\nvar test=JSON.parse(JSON.stringify(msg), function(key, value){\nif (key==\"MSG\"){\n    myMSG = value;\nif (myMSG.startsWith(\"MSG\"))\n{\n  myMSG=myMSG.split(';');\n  myMSG=myMSG[0];\n  //console.log(myMSG);\n}\nelse{\nvar prova = myMSG.search(\"MSG\");\nvar prova1 = myMSG.search(\":\");\n//console.log(prova);\n if ((prova1-prova)==4) \n {\n \tmyMSG =myMSG.substr((prova1-prova+1),(myMSG.length-1));//Elimino ; stringa\n  //console.log(myMSG)\n }\n    myMSG=myMSG.split(';');\n    myMSG=myMSG[0];\n//console.log(myMSG);\n    }\n    }\n});\nmyMSG=myMSG + \";\";\n//row=\"MSG1:01042443606B170000000000000000000000000000000000000000000000000000000000000000F07D\";\n//row=\"MODB:01042c429207340000000000000000000000000000000000000000000000000000000000000000000000003f800000f607\";\n//row=\"MSG1:01043C4296C8D2000000003DC3920B3E92AD88000000004202D1F10000000042083C3F00000000C117E19E3F75E2C100000000C18148D8000000004247D40DABF4\";\n//row=\"MSG2:0104083E74BC6A000000009067\";\n if (myMSG !== undefined){\n// if (msg.MSG !== undefined){\n// if (1){\n//     temp=msg.MSG.split(';');\n//     msg.MSG=temp[0]+\";\";//Nel caso vi fosse il pacchetto LoRa filtriamo i dati GA ADD  ed Rssi\n//     row=msg.MSG;\n//console.log(\"row\",row);\n     // row=msg.MSG+';';//bug da risolvere con lora che non mette il ; in coda\nrow = myMSG;\nrow = row.replace(/\\n|\\r/g, \"\");         \n\noutput_msg.MSG=row;\nvar lenReg = 2;\nvar Nreg = 0;\nvar respLen = 0;\nvar datadec = [];\n\nvar msg_id=checkGTWmsg_id(row);//Controllo della tipologia messaggio Master:Cloud/gtw\nvar float_reg_parsed=[];//vettore dei registri decodificati float \nvar reg_parsed=[];//vettore dei registri decodificati  \n\n\n\n// if (row !== undefined){\n// GetRegParsed(row) ; \n GetRegParsed_Zucchetti(row);\n //JSON response\nswitch(msg_id) {\n  case \"0\"://json Registri generici\n\t\t\t\t//output_msg=DecGTWmsg(row);\n\t\t\t\tbreak;\n  case \"1\": //prima richiesta inverter \n\n        msg.ActivePower_Load_Total = reg_parsed[0]*0.01;//accuracy 0.01 - unit kW\n        msg.P_dis_bat = reg_parsed[0]*0.01;//battery charge power 0.01kW\n        msg.V_bat = reg_parsed[1]*0.1;//battery voltage 0.1V\n        msg.I_dis_bat = reg_parsed[2]*0.01;//battery charge current 0.01A\n        msg.SoC = reg_parsed[3];//State of charge 1%\n        msg.Temp_bat = reg_parsed[4];//battery temperature 1Â°C\n        msg.Pgrid = reg_parsed[5]*0.01;//grid power 0.01kW (Pout is positive, Pin is negative)\n        msg.Pload = reg_parsed[6]*0.01;//load power 0.01kW\n        msg.P_enerStor = reg_parsed[7]*0.01;//energy storage power inverter 0.01kW\n        msg.P_pv_gen = reg_parsed[8]*0.01;//PV power generation 0.01kW\n        msg.V_EPS = reg_parsed[9]*0.1;//EPS output voltage 0.1V\n        \n    break;\n  case \"2\": //seconda richiesta inverter\n        msg.En_daily = reg_parsed[0]*0.01;//energy daily 0.01kWh\n        msg.En_day_ingrid = reg_parsed[1]*0.01 ;//energy daily inserita in grid0.01kWh\n        msg.En_day_taken = reg_parsed[2]*0.01;//energy daily presa da grid 0.01kWh\n        msg.EnLoad_day = reg_parsed[3];//load energy daily 0.01kWh\n        msg.TotEn_high = reg_parsed[4];//total energy high 1kWh\n        msg.TotEn_low = reg_parsed[5];//total energy low 1kWh\n        msg.TotEn_high_ingrid = reg_parsed[6];//total energy high inserita in grid 1kW\n        msg.TotEn_low_ingrid = reg_parsed[7];//total energy low inserita in grid 1kW\n        msg.TotEn_high_taken = reg_parsed[8];//total energy high presa da grid 1kW\n        msg.TotEn_low_taken = reg_parsed[9];//total energy high presa da grid 1kW\n        msg.TotEnLoad_high = reg_parsed[10];//Load total energy high 1kW\n        msg.TotEnLoad_low = reg_parsed[11];//Load total energy low 1kW\n\n    break;\n  case \"3\":\n    break;\n  default:\n    // code block\n}\n  \n}\nreturn {msg: output_msg, metadata: metadata, msgType: msgType};\n\n\nfunction DecGTWmsg(DecGtw_msg_String){\nvar local_output={};\nvar telemetry = new RegExp(\"telemetry=\");\nvar telemetryH2O = new RegExp(\"telemetryH2O=\");\nvar evb = new RegExp(\"EVB\");\nvar Telemetry_arr; //telemetry splitted\n//var batt_perc=0;\nswitch (true) {\n    case telemetry.test(DecGtw_msg_String):\n\t\t\t//console.log(\"telemetry\");\n\t\t\tDecGtw_msg_String = DecGtw_msg_String.replace(telemetry, \"\").substr(1, DecGtw_msg_String.length - 1);\n\t\t\tTelemetry_arr = DecGtw_msg_String.split(',');\n\t\t   // console.log(Telemetry);\n\t\t\t  // console.log(\"len1 \"+ testtel);\n\t\t   local_output.timestamp=Telemetry_arr[0]; \n       local_output.temperature=Telemetry_arr[1];   \n       local_output.humidity=Telemetry_arr[2]; \n       local_output.in_state=Telemetry_arr[3];\n\t\t   local_output.out_state=Telemetry_arr[4];       \n       local_output.current=Telemetry_arr[5];     \n       local_output.Batt=Telemetry_arr[6];    \n       local_output.ax=Telemetry_arr[7];\n\t\t   local_output.n_imp_tot=Telemetry_arr[8];          \n       local_output.portata=Telemetry_arr[9];          \n       local_output.sc_pci=Telemetry_arr[10];\n       local_output.sc_ecl=Telemetry_arr[11]; \n       local_output.sc_rssi=Telemetry_arr[12];\n       \n       var batt_cell=(local_output.Batt/6).toFixed(2);\n       //console.log((local_output.Batt));\n       //console.log(Number(batt_cell));\n       if (batt_cell<2) {local_output.batt_perc = '0';} \n       else if ((batt_cell>=2) && (batt_cell<2.1)) {local_output.batt_perc = '20';} \n       else if ((batt_cell>=2.1) && (batt_cell<2.2)) {local_output.batt_perc = '40';} \n       else if ((batt_cell>=2.2) && (batt_cell<2.3)) {local_output.batt_perc = '60';} \n       else if ((batt_cell>=2.3) && (batt_cell<2.4)) {local_output.batt_perc = '80';} \n       else {local_output.batt_perc = '100';} \n//       if  (batt_cell>=2.4)  local_output.batt_perc = '100'; \n       //console.log(local_output.batt_perc);\n        break;\n    case telemetryH2O.test(DecGtw_msg_String):\n            //console.log(\"telemetryH2O\");\n          DecGtw_msg_String = DecGtw_msg_String.replace(telemetry, \"\").substr(0, DecGtw_msg_String.length - 1);\n           Telemetry_arr = DecGtw_msg_String.split(',');\n     // console.log(Telemetry);\n      //Timestamp,IT,DF,RM,IF,dummy,ECL;\n      local_output.timestamp=Telemetry_arr[0]; local_output.IT=Telemetry_arr[1];       local_output.DF=Telemetry_arr[2];  local_output.RM=Telemetry_arr[3];\n      local_output.IM=Telemetry_arr[4];        local_output.rssi=Telemetry_arr[5];     local_output.ECL=Telemetry_arr[6];\n        break;\n    case evb.test(DecGtw_msg_String):\n         //console.log(\"evb\");\n         DecGtw_msg_String = DecGtw_msg_String.replace(telemetry, \"\").substr(0, DecGtw_msg_String.length - 1);\n         Telemetry_arr = DecGtw_msg_String.split(':');\n\t\t\t if (Telemetry_arr[1]===\"1\") Telemetry_arr[1]=\" open\";\n\t\t\t if (Telemetry_arr[1]===\"0\") Telemetry_arr[1]=\" close\";\n         local_output.Cmd=Telemetry_arr[0]+Telemetry_arr[1];\n        break;\n        default:\n}\n//console.log(local_output);\nreturn local_output;\n}\n\n//return {msg: output_msg, metadata: metadata, msgType: msgType};\n//var strtosearch='MODB:';\n//Restituisce l'id messaggio se stimolato dal minigateway master modbus\nfunction checkGTWmsg_id(Modbus_String){\n var strtosearch='MSGX:';//Stringa per identificata l'ID=X della richiesta impostatate sul device GTW_NBIoT\n var p = row.search(\"MODB\");\n var n = row.search(\"MSG\");\n var m = row.search(\":\");\n var local_msg_id=\"0\";\n   if (((m-n)==4) || ((m-p)==4)){\n       row =row.substr(0,(row.length-1));//Elimino ; stringa\n       if(n===0)  {local_msg_id=row.substr(3,1);} //Contiene l'identificativo della richiesta utilizzata per identificare la grandezza richiesta\n   row =row.substr((m+1),row.length);//Elimino dalla stringa l'header relativo al comando\n  } \nvar testodd = row.length % 2;// 'Controllo che la stringa sia pari \n  if (testodd===1) row='0'+row;\nreturn local_msg_id;\n }\n \n function GetRegParsed(Modbus_String){\n     //Modbus parameter\nvar modbus_addr =1;//indirizzo da filtrare\nvar recived_add;\nvar lenReg=4;//lunghezza in bytes della risposta  (registro richiesto) dipende dalla chiamata \nvar Nreg=0;//\nrecived_add=dataConverter(row,0,2,0);//Estrazione del Modbus address dalla risposta\n//output_msg.add = recived_add;   \n //output_msg.fnc = dataConverter(row,2,2,0);\nvar len_responce= dataConverter(row,4,2,0);//Estrazione Modbus response len bytes\n//output_msg.len = len_responce;\n    if((recived_add===modbus_addr) && (len_responce >2) && (((len_responce+5)*2)===row.length)){\n        Nreg=len_responce/lenReg;//Numero registri da convertire\n        output_msg.Nreg=Nreg;\n        for(var j=0;j<Nreg;j++){\n            var point2Reg=6+j*8;\n            float_reg_parsed[j]=dataConverter(row,point2Reg,8,1);\n        }\n\n\t}\n}\n\nfunction GetRegParsed_Zucchetti(Modbus_String){\n     //Modbus parameter\nvar modbus_addr = 1;//indirizzo da filtrare\nvar received_add;\nvar lenReg=2;//lunghezza in bytes della risposta  (registro richiesto) dipende dalla chiamata \nvar Nreg=0;//\nreceived_add=dataConverter(row,0,2,0);//Estrazione del Modbus address dalla risposta\n\nvar len_response= dataConverter(row,4,2,0);//Estrazione Modbus response len bytes\n//output_msg.len = len_responce;\n    if((received_add===modbus_addr) && (len_response >=2) && (((len_response+5)*2)===row.length)){\n        Nreg=len_response/lenReg;//Numero registri da convertire\n        output_msg.Nreg=Nreg;\n        //console.log(\"Nreg\",output_msg.Nreg);\n        for(var j=0;j<Nreg;j++){\n            var point2Reg=6+j*4;\n            reg_parsed[j]=dataConverter(row,point2Reg,4,0);\n        }\n\n}    \n     \n }\n\n\n function dataConverter(decoded,byteIdxFrom,byteIdxTo,type){\n//var bytes=decoded.substr(byteIdxFrom,byteIdxTo);\n\nvar val=0;\nif (type===0){//Coversione in integer\n    val=parseInt(decoded.substr(byteIdxFrom,byteIdxTo),16);\n}\nif (type==1){//Conversione in float\n val=parseInt(decoded.substr(byteIdxFrom,byteIdxTo),16); \n val=hex2float(val);\n val=Math.round(val*100)/100;\n}\n   if (type == 2) {//Float middle endian per lettore portata AQL\n     var tempH=decoded.substr(byteIdxFrom+4,\n                              byteIdxTo-4);\n     var tempL=decoded.substr(byteIdxFrom,\n                              byteIdxTo-4);\n     tempH+=tempL; \n     val = parseInt(tempH,16);\n     //val = parseInt(decoded.substr(byteIdxFrom,byteIdxTo), 16);\n     val = hex2float(val);\n     val = Math.round(val * 100) / 100;\n   }\nreturn val;\n}\n\nfunction hex2float(num) {\n    var sign = (num & 0x80000000) ? -1 : 1;\n    var exponent = ((num >> 23) & 0xff) - 127;\n    var mantissa = 1 + ((num & 0x7fffff) / 0x7fffff);\n    return sign * mantissa * Math.pow(2, exponent);\n}\n\nfunction crctest(s) {\n var crcRX= parseInt(s.substr(s.length-4,s.length),16);\n var crccalc=crc16(s.substr(0,s.length-4));\n \n //var crccalc=crc16(row);\n//    console.log(\" crcRX:\"+ crcRX );  \n//     console.log(\"function crccalc:\"+ crccalc);  \nif (crcRX == crccalc){\n//console.log(\"function test ok:\" );  \nreturn 1;\n}else   return 0;\n}\n\nfunction crc16(s) {\n    var crc = 0xFFFF;\n    var j, i;\n\n var crcTable = [\n0X0000, 0XC0C1, 0XC181, 0X0140, 0XC301, 0X03C0, 0X0280, 0XC241,\n0XC601, 0X06C0, 0X0780, 0XC741, 0X0500, 0XC5C1, 0XC481, 0X0440,\n0XCC01, 0X0CC0, 0X0D80, 0XCD41, 0X0F00, 0XCFC1, 0XCE81, 0X0E40,\n0X0A00, 0XCAC1, 0XCB81, 0X0B40, 0XC901, 0X09C0, 0X0880, 0XC841,\n0XD801, 0X18C0, 0X1980, 0XD941, 0X1B00, 0XDBC1, 0XDA81, 0X1A40,\n0X1E00, 0XDEC1, 0XDF81, 0X1F40, 0XDD01, 0X1DC0, 0X1C80, 0XDC41,\n0X1400, 0XD4C1, 0XD581, 0X1540, 0XD701, 0X17C0, 0X1680, 0XD641,\n0XD201, 0X12C0, 0X1380, 0XD341, 0X1100, 0XD1C1, 0XD081, 0X1040,\n0XF001, 0X30C0, 0X3180, 0XF141, 0X3300, 0XF3C1, 0XF281, 0X3240,\n0X3600, 0XF6C1, 0XF781, 0X3740, 0XF501, 0X35C0, 0X3480, 0XF441,\n0X3C00, 0XFCC1, 0XFD81, 0X3D40, 0XFF01, 0X3FC0, 0X3E80, 0XFE41,\n0XFA01, 0X3AC0, 0X3B80, 0XFB41, 0X3900, 0XF9C1, 0XF881, 0X3840,\n0X2800, 0XE8C1, 0XE981, 0X2940, 0XEB01, 0X2BC0, 0X2A80, 0XEA41,\n0XEE01, 0X2EC0, 0X2F80, 0XEF41, 0X2D00, 0XEDC1, 0XEC81, 0X2C40,\n0XE401, 0X24C0, 0X2580, 0XE541, 0X2700, 0XE7C1, 0XE681, 0X2640,\n0X2200, 0XE2C1, 0XE381, 0X2340, 0XE101, 0X21C0, 0X2080, 0XE041,\n0XA001, 0X60C0, 0X6180, 0XA141, 0X6300, 0XA3C1, 0XA281, 0X6240,\n0X6600, 0XA6C1, 0XA781, 0X6740, 0XA501, 0X65C0, 0X6480, 0XA441,\n0X6C00, 0XACC1, 0XAD81, 0X6D40, 0XAF01, 0X6FC0, 0X6E80, 0XAE41,\n0XAA01, 0X6AC0, 0X6B80, 0XAB41, 0X6900, 0XA9C1, 0XA881, 0X6840,\n0X7800, 0XB8C1, 0XB981, 0X7940, 0XBB01, 0X7BC0, 0X7A80, 0XBA41,\n0XBE01, 0X7EC0, 0X7F80, 0XBF41, 0X7D00, 0XBDC1, 0XBC81, 0X7C40,\n0XB401, 0X74C0, 0X7580, 0XB541, 0X7700, 0XB7C1, 0XB681, 0X7640,\n0X7200, 0XB2C1, 0XB381, 0X7340, 0XB101, 0X71C0, 0X7080, 0XB041,\n0X5000, 0X90C1, 0X9181, 0X5140, 0X9301, 0X53C0, 0X5280, 0X9241,\n0X9601, 0X56C0, 0X5780, 0X9741, 0X5500, 0X95C1, 0X9481, 0X5440,\n0X9C01, 0X5CC0, 0X5D80, 0X9D41, 0X5F00, 0X9FC1, 0X9E81, 0X5E40,\n0X5A00, 0X9AC1, 0X9B81, 0X5B40, 0X9901, 0X59C0, 0X5880, 0X9841,\n0X8801, 0X48C0, 0X4980, 0X8941, 0X4B00, 0X8BC1, 0X8A81, 0X4A40,\n0X4E00, 0X8EC1, 0X8F81, 0X4F40, 0X8D01, 0X4DC0, 0X4C80, 0X8C41,\n0X4400, 0X84C1, 0X8581, 0X4540, 0X8701, 0X47C0, 0X4680, 0X8641,\n0X8201, 0X42C0, 0X4380, 0X8341, 0X4100, 0X81C1, 0X8081, 0X4040];\n\n\n // console.log(\"s.length1:\"+s.length );\n\n    for (i = 0; i < s.length/2; i++) {\n var k = i*2;\n        //c = s.charCodeAt(i);\n        //c = s.charAt(i);\n        c = parseInt(s.substr(k,2), 16);\n        if (c > 255) {\n           throw new RangeError();\n        }\n     \n       // console.log(\"index\" ,k + \" sub: \"+s.substr(k,2));\n       // console.log(\"c:\"+c );\n       // j = (c ^ (crc >> 8)) & 0xFF;\n        //crc = crcTable[j] ^ (crc << 8);\n      //  crc = crcTable[j] ^ (crc << 8);\n      // for (let b of data) {\n          crc = (crc >> 8) ^ crcTable[(crc ^ c) & 0x00FF];\n\n\t\t}\n   //console.log(\"crc:\"+crc );\n\t//\treturn (~crc) & 0x0ffff;\n  var crcH=(crc & 0x00FF)<<8;\n  var crcL=(crc >>8) & 0x00FF;\n     \n  crc= crcH | crcL;\n // console.log(\"crc: \"+crc +\" crcH: \"+crcH +\" crcL: \"+crcL  );\n    return (crc) & 0x0ffff;\n        \n   // }\n\n    //return ((crc ^ 0) & 0xFFFF);\n\n}\n\n"
      },
      "createdTime" : 0,
      "debugMode" : false,
      "externalId" : null,
      "id" : {
        "entityType" : "RULE_NODE",
        "id" : "48d8da20-9820-11ed-a76d-9955dd563d2d"
      },
      "name" : "Transform_Modbus",
      "ruleChainId" : null,
      "type" : "org.thingsboard.rule.engine.transform.TbTransformMsgNode"
    }, {
      "additionalInfo" : {
        "description" : "update timeseries",
        "layoutX" : 704,
        "layoutY" : 144
      },
      "configuration" : {
        "defaultTTL" : 0
      },
      "createdTime" : 0,
      "debugMode" : false,
      "externalId" : null,
      "id" : {
        "entityType" : "RULE_NODE",
        "id" : "48d90130-9820-11ed-a76d-9955dd563d2d"
      },
      "name" : "Inverter Update",
      "ruleChainId" : null,
      "type" : "org.thingsboard.rule.engine.telemetry.TbMsgTimeseriesNode"
    } ],
    "ruleChainConnections" : null
  },
  "relations" : [ ],
  "attributes" : {
    "SERVER_SCOPE" : [ ]
  }
}